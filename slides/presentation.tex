\documentclass{beamer}

\newcommand{\email}[1]{\texttt{#1}}

\title{mqtt-locust}
\author[Bentley, Mason]
{
    M. Bentley \and A. Mason\\
    \email{\{void,null\}@case.edu}
}
\institute[CWRU]{Case Western Reserve University}

\begin{document}
\frame{\titlepage}

\begin{frame}
    \frametitle{Locust}
    \begin{enumerate}
        \item Load testing framework written in Python
        \item
            Distributed model out of the box
            \begin{enumerate}
                \item Can be run in master-slave configuration to put your
                machines under even higher load
            \end{enumerate}
        \item
            Butâ€¦ only supports HTTP out of the box
            \begin{enumerate}
                \item Can be extended for any protocol by writing a client that
                fires success/failure events
            \end{enumerate}
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Extending locust to support MQTT}
    \begin{enumerate}
        \item Fairly easy to do, on the surface level.
        \item Focused mainly on \texttt{publish} behavior, but would be easy to
        add other user behaviors (e.g. \texttt{subscribe} and verify a message
        was received).
        \item
            Other tools for load-testing mqtt brokers:
            \begin{enumerate}
                \item
                    \href{https://github.com/leandog/mqtt-malaria}{mqtt-malaria}
                    \begin{enumerate}
                        \item However, mqtt-malaria only scales horizontally to
                        the number of cores on a single machine. Using locust
                        will allow us to scale our testing to many machines.
                    \end{enumerate}
            \end{enumerate}
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Issues}
    \framesubtitle{Overwhelming the broker with too many connections}
    \begin{enumerate}
        \item Each ``user'' would open it`s own connection to the broker. So,
        to send $n$ messages simltaneously, we would need $n$ simultaneous
        connections to the broker. This significantly limited the amount we
        could scale mqtt-locust.

        \item Solution: Override the \texttt{publish} method to take a
        \texttt{repeat} keyword argument. Each ``user'' would then send
        \texttt{repeat} messages. This way, we can send the same number of
        messages with fewer connections to the broker.
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Issues}
    \framesubtitle{Tracking messages; Python threads and stuff}
    \begin{enumerate}
        \item To track messages, we store them in a dictionary, and then use
        the underlying \texttt{on\_publish} method to fire the various locust
        events.

        \item But, as load increases, messages get published faster than
        \texttt{on\_publish} can enumerate the dictionary. Python then
        complains that the size of the dictionary is changing during
        enumeration.

        \item Solution: Using \texttt{dict(mmap)}, we get a copy of the
        dictionary, which we can then enumerate safely. This operation
        completes quickly enough that we don't get the previous error.
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{mqtt-locust results}
    \framesubtitle{Finding where more users send no more messages}
    \begin{enumerate}
        \item Baseline (no usage):
            \begin{enumerate}
                \item 43k publishes received per minute
                \item 8\% CPU usage
                \item 0 network usage
            \end{enumerate}
        \item 1000 users:
            \begin{enumerate}
                \item 435k publishes received per minute
                \item 100\% CPU usage
                \item 1.5MB/s network in
                \item 1\% message failure
            \end{enumerate}
        \item 4000 users (maximum):
            \begin{enumerate}
                \item 1 million publishes received per minute
                \item 100\% CPU usage
                \item 4MB/s network in
                \item 7\% message failure
            \end{enumerate}
        \item 5000 users (no increase in messages):
            \begin{enumerate}
                \item 1 million publishes received per minute
                \item 100\% CPU usage
                \item 4MB/s network in
                \item 8\% message failure
            \end{enumerate}
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{mqtt-locust vs mqtt-malaria}
    \begin{enumerate}
        \item mqtt-malaria is much less robust
        \item
            Even on the same server under ideal conditions we could only make
            mqtt-malaria publish 500k messages per minute
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Future Work and Goals}
    \begin{enumerate}
        \item
            Clean up connections on close.
        \item
            Handle disconnecting and reconnecting cleanly.
            \begin{enumerate}
                \item
                    mqtt connections occasionally fail for reasons out of our
                    control
                \item We should handle this gracefully and log that it happened
            \end{enumerate}
        \item
            Should error upon double-receiving a message. Or, at least log a
            warning.
            \begin{enumerate}
                \item
                    \texttt{qos=1} guarantees that the message will be
                    delivered at least once
                \item We should track when a message is received more than once
            \end{enumerate}
        \item
            Submit to upstream locust to have mqtt support included by default.
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Conclusion}
    \begin{enumerate}
        \item
            Locust is a pretty good framework and was designed for
            extensibility, which helped us a lot. There were a few edge cases
            with regard to the MQTT protocol that we had to work out, though.
        \item
            The master/slave design of locust allows the load testing to scale
            horizonatally quite nicely, which is a huge advantage over a tool
            like malaria.
        \item
            Mosquitto is still really, really hard to knock over.
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Questions?}
\end{frame}
\end{document}
